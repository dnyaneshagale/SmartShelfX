package com.infosys.smartshelfx.service;

import com.infosys.smartshelfx.dtos.*;
import com.infosys.smartshelfx.entity.*;
import com.infosys.smartshelfx.repository.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Purchase Order Service
 * - Auto-generate POs based on AI suggestions
 * - Manual PO creation
 * - PO approval workflow
 * - Vendor notifications
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class PurchaseOrderService {

    private final PurchaseOrderRepository purchaseOrderRepository;
    private final PurchaseOrderItemRepository purchaseOrderItemRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;
    private final DemandForecastRepository demandForecastRepository;
    private final NotificationService notificationService;
    private final AuditLogService auditLogService;

    /**
     * Create a new purchase order
     */
    @Transactional
    public PurchaseOrderDTO createPurchaseOrder(PurchaseOrderCreateRequest request) {
        User vendor = userRepository.findById(request.getVendorId())
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Vendor not found with id: " + request.getVendorId()));

        if (vendor.getRole() != Role.VENDOR && vendor.getRole() != Role.ADMIN) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "User is not a vendor: " + request.getVendorId());
        }

        User currentUser = getCurrentUser();

        PurchaseOrder po = PurchaseOrder.builder()
                .poNumber(generatePONumber())
                .vendor(vendor)
                .status(PurchaseOrderStatus.DRAFT)
                .notes(request.getNotes())
                .shippingAddress(request.getShippingAddress())
                .expectedDeliveryDate(request.getExpectedDeliveryDate())
                .taxAmount(request.getTaxAmount())
                .shippingCost(request.getShippingCost())
                .createdBy(currentUser)
                .isAutoGenerated(false)
                .build();

        po = purchaseOrderRepository.save(po);

        // Add items
        for (PurchaseOrderCreateRequest.PurchaseOrderItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findById(itemRequest.getProductId())
                    .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                            "Product not found with id: " + itemRequest.getProductId()));

            BigDecimal unitPrice = itemRequest.getUnitPrice() != null ? itemRequest.getUnitPrice()
                    : product.getCostPrice();

            PurchaseOrderItem item = PurchaseOrderItem.builder()
                    .purchaseOrder(po)
                    .product(product)
                    .quantity(itemRequest.getQuantity())
                    .unitPrice(unitPrice != null ? unitPrice : BigDecimal.ZERO)
                    .notes(itemRequest.getNotes())
                    .build();

            purchaseOrderItemRepository.save(item);
            po.getItems().add(item);
        }

        // Calculate totals
        po.calculateTotals();
        po = purchaseOrderRepository.save(po);

        auditLogService.logAction(AuditAction.CREATE, "PurchaseOrder", po.getId(),
                null, po, "created");

        log.info("Purchase order created: {}", po.getPoNumber());

        return toDTO(po);
    }

    /**
     * Auto-generate POs based on restock suggestions
     */
    @Transactional
    public List<PurchaseOrderDTO> autoGeneratePurchaseOrders() {
        // Get products at risk
        List<DemandForecast> atRiskForecasts = demandForecastRepository.findProductsAtRisk();

        // Group by vendor
        Map<Long, List<DemandForecast>> byVendor = atRiskForecasts.stream()
                .collect(Collectors.groupingBy(df -> df.getProduct().getVendor().getId()));

        List<PurchaseOrderDTO> createdPOs = new ArrayList<>();

        for (Map.Entry<Long, List<DemandForecast>> entry : byVendor.entrySet()) {
            Long vendorId = entry.getKey();
            List<DemandForecast> forecasts = entry.getValue();

            // Create PO for this vendor
            User vendor = userRepository.findById(vendorId).orElse(null);
            if (vendor == null)
                continue;

            User systemUser = getCurrentUser(); // Or use a system user

            PurchaseOrder po = PurchaseOrder.builder()
                    .poNumber(generatePONumber())
                    .vendor(vendor)
                    .status(PurchaseOrderStatus.PENDING)
                    .notes("Auto-generated based on AI demand forecast")
                    .createdBy(systemUser)
                    .isAutoGenerated(true)
                    .build();

            po = purchaseOrderRepository.save(po);

            // Add items
            for (DemandForecast forecast : forecasts) {
                Product product = forecast.getProduct();
                int quantity = forecast.getRecommendedRestock() != null ? forecast.getRecommendedRestock()
                        : product.getReorderQuantity();

                PurchaseOrderItem item = PurchaseOrderItem.builder()
                        .purchaseOrder(po)
                        .product(product)
                        .quantity(quantity)
                        .unitPrice(product.getCostPrice() != null ? product.getCostPrice() : BigDecimal.ZERO)
                        .notes("AI-suggested restock - Days until stockout: " + forecast.getDaysUntilStockout())
                        .build();

                purchaseOrderItemRepository.save(item);
                po.getItems().add(item);
            }

            // Calculate totals
            po.calculateTotals();
            po = purchaseOrderRepository.save(po);

            // Notify vendor
            notificationService.createPurchaseOrderNotification(po, NotificationType.PURCHASE_ORDER_CREATED);

            createdPOs.add(toDTO(po));
            log.info("Auto-generated PO: {} for vendor: {}", po.getPoNumber(), vendor.getUsername());
        }

        return createdPOs;
    }

    /**
     * Get restock suggestions
     */
    public List<RestockSuggestionDTO> getRestockSuggestions() {
        List<Product> lowStockProducts = productRepository.findLowStockProducts();
        List<DemandForecast> forecasts = demandForecastRepository.findProductsAtRisk();

        Map<Long, DemandForecast> forecastMap = forecasts.stream()
                .collect(Collectors.toMap(df -> df.getProduct().getId(), df -> df, (a, b) -> a));

        List<RestockSuggestionDTO> suggestions = new ArrayList<>();

        for (Product product : lowStockProducts) {
            DemandForecast forecast = forecastMap.get(product.getId());

            String urgency = "MEDIUM";
            int suggestedQuantity = product.getReorderQuantity();
            String reason = "Stock below reorder level";

            if (forecast != null) {
                if (forecast.getDaysUntilStockout() != null) {
                    if (forecast.getDaysUntilStockout() <= 3) {
                        urgency = "CRITICAL";
                        reason = "Stockout predicted in " + forecast.getDaysUntilStockout() + " days";
                    } else if (forecast.getDaysUntilStockout() <= 7) {
                        urgency = "HIGH";
                        reason = "Stockout predicted in " + forecast.getDaysUntilStockout() + " days";
                    }
                }
                if (forecast.getRecommendedRestock() != null) {
                    suggestedQuantity = forecast.getRecommendedRestock();
                }
            }

            if (product.getStockStatus() == StockStatus.OUT_OF_STOCK) {
                urgency = "CRITICAL";
                reason = "Product is out of stock";
            }

            suggestions.add(RestockSuggestionDTO.builder()
                    .productId(product.getId())
                    .productName(product.getName())
                    .productSku(product.getSku())
                    .vendorId(product.getVendor().getId())
                    .vendorName(product.getVendor().getUsername())
                    .categoryId(product.getCategory().getId())
                    .categoryName(product.getCategory().getName())
                    .currentStock(product.getCurrentStock())
                    .reorderLevel(product.getReorderLevel())
                    .reorderQuantity(product.getReorderQuantity())
                    .suggestedQuantity(suggestedQuantity)
                    .predictedDemand(forecast != null ? forecast.getPredictedDemand() : null)
                    .daysUntilStockout(forecast != null ? forecast.getDaysUntilStockout() : null)
                    .urgency(urgency)
                    .confidenceScore(forecast != null ? forecast.getConfidenceScore() : null)
                    .reason(reason)
                    .autoApproved(false)
                    .build());
        }

        // Sort by urgency
        suggestions.sort((a, b) -> {
            Map<String, Integer> urgencyOrder = Map.of(
                    "CRITICAL", 0, "HIGH", 1, "MEDIUM", 2, "LOW", 3);
            return urgencyOrder.getOrDefault(a.getUrgency(), 4)
                    - urgencyOrder.getOrDefault(b.getUrgency(), 4);
        });

        return suggestions;
    }

    /**
     * Submit PO for approval
     */
    @Transactional
    public PurchaseOrderDTO submitForApproval(Long poId) {
        PurchaseOrder po = purchaseOrderRepository.findById(poId)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Purchase order not found with id: " + poId));

        if (po.getStatus() != PurchaseOrderStatus.DRAFT) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Only draft POs can be submitted for approval");
        }

        po.setStatus(PurchaseOrderStatus.PENDING);
        po = purchaseOrderRepository.save(po);

        notificationService.createPurchaseOrderNotification(po, NotificationType.PURCHASE_ORDER_CREATED);

        return toDTO(po);
    }

    /**
     * Approve PO
     */
    @Transactional
    public PurchaseOrderDTO approvePurchaseOrder(Long poId) {
        PurchaseOrder po = purchaseOrderRepository.findById(poId)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Purchase order not found with id: " + poId));

        if (po.getStatus() != PurchaseOrderStatus.PENDING) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Only pending POs can be approved");
        }

        User currentUser = getCurrentUser();
        po.setStatus(PurchaseOrderStatus.APPROVED);
        po.setApprovedBy(currentUser);
        po.setApprovedAt(LocalDateTime.now());
        po = purchaseOrderRepository.save(po);

        notificationService.createPurchaseOrderNotification(po, NotificationType.PURCHASE_ORDER_APPROVED);

        auditLogService.logAction(AuditAction.UPDATE, "PurchaseOrder", po.getId(), "approved");

        return toDTO(po);
    }

    /**
     * Reject PO
     */
    @Transactional
    public PurchaseOrderDTO rejectPurchaseOrder(Long poId, String reason) {
        PurchaseOrder po = purchaseOrderRepository.findById(poId)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Purchase order not found with id: " + poId));

        if (po.getStatus() != PurchaseOrderStatus.PENDING) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "Only pending POs can be rejected");
        }

        po.setStatus(PurchaseOrderStatus.REJECTED);
        po.setNotes(po.getNotes() != null ? po.getNotes() + "\nRejection reason: " + reason
                : "Rejection reason: " + reason);
        po = purchaseOrderRepository.save(po);

        notificationService.createPurchaseOrderNotification(po, NotificationType.PURCHASE_ORDER_REJECTED);

        return toDTO(po);
    }

    /**
     * Mark PO as received (partial or full)
     */
    @Transactional
    public PurchaseOrderDTO receivePurchaseOrder(Long poId, List<PurchaseOrderItemDTO> receivedItems) {
        PurchaseOrder po = purchaseOrderRepository.findById(poId)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Purchase order not found with id: " + poId));

        if (po.getStatus() != PurchaseOrderStatus.APPROVED &&
                po.getStatus() != PurchaseOrderStatus.SENT &&
                po.getStatus() != PurchaseOrderStatus.ACKNOWLEDGED &&
                po.getStatus() != PurchaseOrderStatus.PARTIALLY_RECEIVED) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                    "PO must be approved or sent to receive items");
        }

        boolean allReceived = true;
        for (PurchaseOrderItemDTO receivedItem : receivedItems) {
            PurchaseOrderItem item = purchaseOrderItemRepository.findById(receivedItem.getId())
                    .orElse(null);
            if (item != null) {
                int newReceivedQty = (item.getReceivedQuantity() != null ? item.getReceivedQuantity() : 0)
                        + receivedItem.getReceivedQuantity();
                item.setReceivedQuantity(newReceivedQty);
                purchaseOrderItemRepository.save(item);

                if (newReceivedQty < item.getQuantity()) {
                    allReceived = false;
                }
            }
        }

        po.setStatus(allReceived ? PurchaseOrderStatus.RECEIVED : PurchaseOrderStatus.PARTIALLY_RECEIVED);
        if (allReceived) {
            po.setActualDeliveryDate(LocalDateTime.now());
        }
        po = purchaseOrderRepository.save(po);

        notificationService.createPurchaseOrderNotification(po, NotificationType.PURCHASE_ORDER_RECEIVED);

        return toDTO(po);
    }

    /**
     * Get all purchase orders with filters
     */
    public Page<PurchaseOrderDTO> getPurchaseOrders(
            Long vendorId, PurchaseOrderStatus status,
            LocalDateTime startDate, LocalDateTime endDate,
            int page, int size) {

        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
        Page<PurchaseOrder> orders = purchaseOrderRepository.findWithFilters(
                vendorId, status, startDate, endDate, pageable);

        return orders.map(this::toDTO);
    }

    /**
     * Get PO by ID
     */
    public PurchaseOrderDTO getPurchaseOrderById(Long poId) {
        PurchaseOrder po = purchaseOrderRepository.findById(poId)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
                        "Purchase order not found with id: " + poId));
        return toDTO(po);
    }

    /**
     * Get POs for vendor
     */
    public Page<PurchaseOrderDTO> getVendorPurchaseOrders(Long vendorId, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
        return purchaseOrderRepository.findByVendorId(vendorId, pageable).map(this::toDTO);
    }

    private String generatePONumber() {
        String dateStr = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        long count = purchaseOrderRepository.count() + 1;
        return String.format("PO-%s-%05d", dateStr, count);
    }

    private User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated()) {
            String username = authentication.getName();
            return userRepository.findByUsername(username).orElse(null);
        }
        return null;
    }

    private PurchaseOrderDTO toDTO(PurchaseOrder po) {
        List<PurchaseOrderItemDTO> itemDTOs = po.getItems().stream()
                .map(this::toItemDTO)
                .toList();

        return PurchaseOrderDTO.builder()
                .id(po.getId())
                .poNumber(po.getPoNumber())
                .vendorId(po.getVendor().getId())
                .vendorName(po.getVendor().getUsername())
                .vendorEmail(po.getVendor().getEmail())
                .status(po.getStatus())
                .totalAmount(po.getTotalAmount())
                .taxAmount(po.getTaxAmount())
                .shippingCost(po.getShippingCost())
                .grandTotal(po.getGrandTotal())
                .notes(po.getNotes())
                .shippingAddress(po.getShippingAddress())
                .expectedDeliveryDate(po.getExpectedDeliveryDate())
                .actualDeliveryDate(po.getActualDeliveryDate())
                .createdById(po.getCreatedBy() != null ? po.getCreatedBy().getId() : null)
                .createdByName(po.getCreatedBy() != null ? po.getCreatedBy().getUsername() : null)
                .approvedById(po.getApprovedBy() != null ? po.getApprovedBy().getId() : null)
                .approvedByName(po.getApprovedBy() != null ? po.getApprovedBy().getUsername() : null)
                .approvedAt(po.getApprovedAt())
                .createdAt(po.getCreatedAt())
                .updatedAt(po.getUpdatedAt())
                .isAutoGenerated(po.getIsAutoGenerated())
                .items(itemDTOs)
                .totalItems(itemDTOs.size())
                .build();
    }

    private PurchaseOrderItemDTO toItemDTO(PurchaseOrderItem item) {
        return PurchaseOrderItemDTO.builder()
                .id(item.getId())
                .productId(item.getProduct().getId())
                .productName(item.getProduct().getName())
                .productSku(item.getProduct().getSku())
                .quantity(item.getQuantity())
                .unitPrice(item.getUnitPrice())
                .lineTotal(item.getLineTotal())
                .receivedQuantity(item.getReceivedQuantity())
                .currentStock(item.getProduct().getCurrentStock())
                .reorderLevel(item.getProduct().getReorderLevel())
                .notes(item.getNotes())
                .build();
    }
}
